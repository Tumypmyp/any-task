/*
 * Anytype API
 *
 * This API enables seamless interaction with Anytype's resources - spaces, objects, properties, types, templates, and beyond.
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: support@anytype.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSpaceError {
    Status400(models::UtilValidationError),
    Status401(models::UtilUnauthorizedError),
    Status429(models::UtilRateLimitError),
    Status500(models::UtilServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSpaceError {
    Status401(models::UtilUnauthorizedError),
    Status404(models::UtilNotFoundError),
    Status500(models::UtilServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_spaces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSpacesError {
    Status401(models::UtilUnauthorizedError),
    Status500(models::UtilServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSpaceError {
    Status400(models::UtilValidationError),
    Status401(models::UtilUnauthorizedError),
    Status403(models::UtilForbiddenError),
    Status404(models::UtilNotFoundError),
    Status429(models::UtilRateLimitError),
    Status500(models::UtilServerError),
    UnknownValue(serde_json::Value),
}


/// Creates a new space based on a supplied name and description in the JSON request body. The endpoint is subject to rate limiting and automatically applies default configurations such as generating a random icon and initializing the workspace with default settings (for example, a default dashboard or home page). On success, the new space’s full metadata is returned, enabling the client to immediately switch context to the new internal.
pub async fn create_space(configuration: &configuration::Configuration, anytype_version: &str, apimodel_create_space_request: models::ApimodelCreateSpaceRequest) -> Result<models::ApimodelSpaceResponse, Error<CreateSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_body_apimodel_create_space_request = apimodel_create_space_request;

    let uri_str = format!("{}/v1/spaces", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_apimodel_create_space_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApimodelSpaceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApimodelSpaceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches full details about a single space identified by its space ID. The response includes metadata such as the space name, icon, and various workspace IDs (home, archive, profile, etc.). This detailed view supports use cases such as displaying space-specific settings.
pub async fn get_space(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str) -> Result<models::ApimodelSpaceResponse, Error<GetSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;

    let uri_str = format!("{}/v1/spaces/{space_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApimodelSpaceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApimodelSpaceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a paginated list of all spaces that are accessible by the authenticated user. Each space record contains detailed information such as the space ID, name, icon (derived either from an emoji or image URL), and additional metadata. This endpoint is key to displaying a user’s workspaces.
pub async fn list_spaces(configuration: &configuration::Configuration, anytype_version: &str, offset: Option<i32>, limit: Option<i32>) -> Result<models::PaginationPaginatedResponseApimodelSpace, Error<ListSpacesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_query_offset = offset;
    let p_query_limit = limit;

    let uri_str = format!("{}/v1/spaces", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginationPaginatedResponseApimodelSpace`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginationPaginatedResponseApimodelSpace`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSpacesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the name or description of an existing space. The request body should contain the new name and/or description in JSON format. This endpoint is useful for renaming or rebranding a workspace without needing to recreate it. The updated space’s metadata is returned in the response.
pub async fn update_space(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, apimodel_update_space_request: models::ApimodelUpdateSpaceRequest) -> Result<models::ApimodelSpaceResponse, Error<UpdateSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_body_apimodel_update_space_request = apimodel_update_space_request;

    let uri_str = format!("{}/v1/spaces/{space_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_apimodel_update_space_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApimodelSpaceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApimodelSpaceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

