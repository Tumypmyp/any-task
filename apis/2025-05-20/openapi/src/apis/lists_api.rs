/*
 * Anytype API
 *
 * This API enables seamless interaction with Anytype's resources - spaces, objects, properties, types, templates, and beyond.
 *
 * The version of the OpenAPI document: 2025-05-20
 * Contact: support@anytype.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_list_objects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddListObjectsError {
    Status400(models::UtilPeriodValidationError),
    Status401(models::UtilPeriodUnauthorizedError),
    Status404(models::UtilPeriodNotFoundError),
    Status429(models::UtilPeriodRateLimitError),
    Status500(models::UtilPeriodServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_list_objects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetListObjectsError {
    Status401(models::UtilPeriodUnauthorizedError),
    Status404(models::UtilPeriodNotFoundError),
    Status500(models::UtilPeriodServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_list_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetListViewsError {
    Status401(models::UtilPeriodUnauthorizedError),
    Status404(models::UtilPeriodNotFoundError),
    Status500(models::UtilPeriodServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_list_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveListObjectError {
    Status400(models::UtilPeriodValidationError),
    Status401(models::UtilPeriodUnauthorizedError),
    Status404(models::UtilPeriodNotFoundError),
    Status429(models::UtilPeriodRateLimitError),
    Status500(models::UtilPeriodServerError),
    UnknownValue(serde_json::Value),
}


/// Adds one or more objects to a specific list (collection only) by submitting a JSON array of object IDs. Upon success, the endpoint returns a confirmation message. This endpoint is vital for building user interfaces that allow drag‑and‑drop or multi‑select additions to collections, enabling users to dynamically manage their collections without needing to modify the underlying object data.
pub async fn add_list_objects(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, list_id: &str, apimodel_period_add_objects_to_list_request: models::ApimodelPeriodAddObjectsToListRequest) -> Result<String, Error<AddListObjectsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_anytype_version = anytype_version;
    let p_space_id = space_id;
    let p_list_id = list_id;
    let p_apimodel_period_add_objects_to_list_request = apimodel_period_add_objects_to_list_request;

    let uri_str = format!("{}/v1/spaces/{space_id}/lists/{list_id}/objects", configuration.base_path, space_id=crate::apis::urlencode(p_space_id), list_id=crate::apis::urlencode(p_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_apimodel_period_add_objects_to_list_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddListObjectsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of objects associated with a specific list (query or collection) within a space. When a view ID is provided, the objects are filtered and sorted according to the view's configuration. If no view ID is specified, all list objects are returned without filtering and sorting. This endpoint helps clients to manage grouped objects (for example, tasks within a list) by returning information for each item of the list.
pub async fn get_list_objects(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, list_id: &str, view_id: &str, offset: Option<i32>, limit: Option<i32>) -> Result<models::PaginationPeriodPaginatedResponseApimodelObject, Error<GetListObjectsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_anytype_version = anytype_version;
    let p_space_id = space_id;
    let p_list_id = list_id;
    let p_view_id = view_id;
    let p_offset = offset;
    let p_limit = limit;

    let uri_str = format!("{}/v1/spaces/{space_id}/lists/{list_id}/views/{view_id}/objects", configuration.base_path, space_id=crate::apis::urlencode(p_space_id), list_id=crate::apis::urlencode(p_list_id), view_id=crate::apis::urlencode(p_view_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginationPeriodPaginatedResponseApimodelObject`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginationPeriodPaginatedResponseApimodelObject`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetListObjectsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of views defined for a specific list (query or collection) within a space. Each view includes details such as layout, applied filters, and sorting options, enabling clients to render the list according to user preferences and context. This endpoint is essential for applications that need to display lists in various formats (e.g., grid, table) or with different sorting/filtering criteria.
pub async fn get_list_views(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, list_id: &str, offset: Option<i32>, limit: Option<i32>) -> Result<models::PaginationPeriodPaginatedResponseApimodelView, Error<GetListViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_anytype_version = anytype_version;
    let p_space_id = space_id;
    let p_list_id = list_id;
    let p_offset = offset;
    let p_limit = limit;

    let uri_str = format!("{}/v1/spaces/{space_id}/lists/{list_id}/views", configuration.base_path, space_id=crate::apis::urlencode(p_space_id), list_id=crate::apis::urlencode(p_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginationPeriodPaginatedResponseApimodelView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginationPeriodPaginatedResponseApimodelView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetListViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a given object from the specified list (collection only) in a space. The endpoint takes the space, list, and object identifiers as path parameters and is subject to rate limiting. It is used for dynamically managing collections without affecting the underlying object data.
pub async fn remove_list_object(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, list_id: &str, object_id: &str) -> Result<String, Error<RemoveListObjectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_anytype_version = anytype_version;
    let p_space_id = space_id;
    let p_list_id = list_id;
    let p_object_id = object_id;

    let uri_str = format!("{}/v1/spaces/{space_id}/lists/{list_id}/objects/{object_id}", configuration.base_path, space_id=crate::apis::urlencode(p_space_id), list_id=crate::apis::urlencode(p_list_id), object_id=crate::apis::urlencode(p_object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveListObjectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

