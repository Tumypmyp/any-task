/*
 * Anytype API
 *
 * This API enables seamless interaction with Anytype's resources - spaces, objects, properties, types, templates, and beyond.
 *
 * The version of the OpenAPI document: 2025-11-08
 * Contact: support@anytype.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTagError {
    Status400(models::ValidationError),
    Status401(models::UnauthorizedError),
    Status429(models::RateLimitError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTagError {
    Status401(models::UnauthorizedError),
    Status403(models::ForbiddenError),
    Status404(models::NotFoundError),
    Status410(models::GoneError),
    Status429(models::RateLimitError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTagError {
    Status401(models::UnauthorizedError),
    Status404(models::NotFoundError),
    Status410(models::GoneError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_tags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTagsError {
    Status401(models::UnauthorizedError),
    Status404(models::NotFoundError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTagError {
    Status400(models::ValidationError),
    Status401(models::UnauthorizedError),
    Status403(models::ForbiddenError),
    Status404(models::NotFoundError),
    Status410(models::GoneError),
    Status429(models::RateLimitError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}


/// This endpoint creates a new tag for a given property id in a space. The creation process is subject to rate limiting. The tag is identified by its unique identifier within the specified space. The request must include the tag's name and color. The response includes the tag's details such as its ID, name, and color. This is useful for clients when users want to add new tag options to a property.
pub async fn create_tag(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, property_id: &str, create_tag_request: models::CreateTagRequest) -> Result<models::TagResponse, Error<CreateTagError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_property_id = property_id;
    let p_body_create_tag_request = create_tag_request;

    let uri_str = format!("{}/v1/spaces/{space_id}/properties/{property_id}/tags", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), property_id=crate::apis::urlencode(p_path_property_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_tag_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint “deletes” a tag by marking it as archived. The deletion process is performed safely and is subject to rate limiting. It returns the tag’s details after it has been archived. Proper error handling is in place for situations such as when the tag isn’t found or the deletion cannot be performed because of permission issues.
pub async fn delete_tag(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, property_id: &str, tag_id: &str) -> Result<models::TagResponse, Error<DeleteTagError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_property_id = property_id;
    let p_path_tag_id = tag_id;

    let uri_str = format!("{}/v1/spaces/{space_id}/properties/{property_id}/tags/{tag_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), property_id=crate::apis::urlencode(p_path_property_id), tag_id=crate::apis::urlencode(p_path_tag_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint retrieves a tag for a given property id. The tag is identified by its unique identifier within the specified space. The response includes the tag's details such as its ID, name, and color. This is useful for clients to display or when editing a specific tag option.
pub async fn get_tag(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, property_id: &str, tag_id: &str) -> Result<models::TagResponse, Error<GetTagError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_property_id = property_id;
    let p_path_tag_id = tag_id;

    let uri_str = format!("{}/v1/spaces/{space_id}/properties/{property_id}/tags/{tag_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), property_id=crate::apis::urlencode(p_path_property_id), tag_id=crate::apis::urlencode(p_path_tag_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint retrieves a paginated list of tags available for a specific property within a space. Each tag record includes its unique identifier, name, and color. This information is essential for clients to display select or multi-select options to users when they are creating or editing objects. The endpoint also supports pagination through offset and limit parameters. Supports dynamic filtering via query parameters (e.g., ?name[contains]=urgent). See FilterCondition enum for available conditions.
pub async fn list_tags(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, property_id: &str) -> Result<models::PaginatedResponseTag, Error<ListTagsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_property_id = property_id;

    let uri_str = format!("{}/v1/spaces/{space_id}/properties/{property_id}/tags", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), property_id=crate::apis::urlencode(p_path_property_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedResponseTag`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedResponseTag`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTagsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint updates a tag for a given property id in a space. The update process is subject to rate limiting. The tag is identified by its unique identifier within the specified space. The request must include the tag's name and color. The response includes the tag's details such as its ID, name, and color. This is useful for clients when users want to edit existing tags for a property.
pub async fn update_tag(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, property_id: &str, tag_id: &str, update_tag_request: models::UpdateTagRequest) -> Result<models::TagResponse, Error<UpdateTagError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_property_id = property_id;
    let p_path_tag_id = tag_id;
    let p_body_update_tag_request = update_tag_request;

    let uri_str = format!("{}/v1/spaces/{space_id}/properties/{property_id}/tags/{tag_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), property_id=crate::apis::urlencode(p_path_property_id), tag_id=crate::apis::urlencode(p_path_tag_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_tag_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TagResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TagResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTagError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

