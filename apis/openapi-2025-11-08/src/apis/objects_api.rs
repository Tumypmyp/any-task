/*
 * Anytype API
 *
 * This API enables seamless interaction with Anytype's resources - spaces, objects, properties, types, templates, and beyond.
 *
 * The version of the OpenAPI document: 2025-11-08
 * Contact: support@anytype.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateObjectError {
    Status400(models::ValidationError),
    Status401(models::UnauthorizedError),
    Status429(models::RateLimitError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteObjectError {
    Status401(models::UnauthorizedError),
    Status403(models::ForbiddenError),
    Status404(models::NotFoundError),
    Status410(models::GoneError),
    Status429(models::RateLimitError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetObjectError {
    Status401(models::UnauthorizedError),
    Status404(models::NotFoundError),
    Status410(models::GoneError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_objects`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListObjectsError {
    Status401(models::UnauthorizedError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_object`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateObjectError {
    Status400(models::ValidationError),
    Status401(models::UnauthorizedError),
    Status404(models::NotFoundError),
    Status410(models::GoneError),
    Status429(models::RateLimitError),
    Status500(models::ServerError),
    UnknownValue(serde_json::Value),
}


/// Creates a new object in the specified space using a JSON payload. The creation process is subject to rate limiting. The payload must include key details such as the object name, icon, description, body content (which may support Markdown), source URL (required for bookmark objects), template identifier, and the type_key (which is the non-unique identifier of the type of object to create). Post-creation, additional operations (like setting featured properties or fetching bookmark metadata) may occur. The endpoint then returns the full object data, ready for further interactions.
pub async fn create_object(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, create_object_request: models::CreateObjectRequest) -> Result<models::ObjectResponse, Error<CreateObjectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_body_create_object_request = create_object_request;

    let uri_str = format!("{}/v1/spaces/{space_id}/objects", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_object_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObjectResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObjectResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateObjectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint “deletes” an object by marking it as archived. The deletion process is performed safely and is subject to rate limiting. It returns the object’s details after it has been archived. Proper error handling is in place for situations such as when the object isn’t found or the deletion cannot be performed because of permission issues.
pub async fn delete_object(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, object_id: &str) -> Result<models::ObjectResponse, Error<DeleteObjectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_object_id = object_id;

    let uri_str = format!("{}/v1/spaces/{space_id}/objects/{object_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), object_id=crate::apis::urlencode(p_path_object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObjectResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObjectResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteObjectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetches the full details of a single object identified by the object ID within the specified space. The response includes not only basic metadata (ID, name, icon, type) but also the complete set of blocks (which may include text, files, properties and dataviews) and extra details (such as timestamps and linked member information). This endpoint is essential when a client needs to render or edit the full object view.
pub async fn get_object(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, object_id: &str, format: Option<&str>) -> Result<models::ObjectResponse, Error<GetObjectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_object_id = object_id;
    let p_query_format = format;

    let uri_str = format!("{}/v1/spaces/{space_id}/objects/{object_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), object_id=crate::apis::urlencode(p_path_object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObjectResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObjectResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetObjectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a paginated list of objects in the given space. The endpoint takes query parameters for pagination (offset and limit) and returns detailed data about each object including its ID, name, icon, type information, a snippet of the content (if applicable), layout, space ID, blocks and details. It is intended for building views where users can see all objects in a space at a glance. Supports dynamic filtering via query parameters (e.g., ?done=false, ?created_date[gte]=2024-01-01, ?tags[in]=urgent,important). For select/multi_select properties you can use either tag keys or tag IDs, for object properties use object IDs. See FilterCondition enum for available conditions.
pub async fn list_objects(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, offset: Option<i32>, limit: Option<i32>) -> Result<models::PaginatedResponseObject, Error<ListObjectsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_query_offset = offset;
    let p_query_limit = limit;

    let uri_str = format!("{}/v1/spaces/{space_id}/objects", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedResponseObject`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedResponseObject`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListObjectsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint updates an existing object in the specified space using a JSON payload. The update process is subject to rate limiting. The payload must include the details to be updated. The endpoint then returns the full object data, ready for further interactions.
pub async fn update_object(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, object_id: &str, update_object_request: models::UpdateObjectRequest) -> Result<models::ObjectResponse, Error<UpdateObjectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_anytype_version = anytype_version;
    let p_path_space_id = space_id;
    let p_path_object_id = object_id;
    let p_body_update_object_request = update_object_request;

    let uri_str = format!("{}/v1/spaces/{space_id}/objects/{object_id}", configuration.base_path, space_id=crate::apis::urlencode(p_path_space_id), object_id=crate::apis::urlencode(p_path_object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_header_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_object_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObjectResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObjectResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateObjectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

