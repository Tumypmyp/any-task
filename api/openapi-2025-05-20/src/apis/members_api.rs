/*
 * Anytype API
 *
 * This API enables seamless interaction with Anytype's resources - spaces, objects, properties, types, templates, and beyond.
 *
 * The version of the OpenAPI document: 2025-05-20
 * Contact: support@anytype.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMemberError {
    Status401(models::UtilPeriodUnauthorizedError),
    Status404(models::UtilPeriodNotFoundError),
    Status500(models::UtilPeriodServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMembersError {
    Status401(models::UtilPeriodUnauthorizedError),
    Status500(models::UtilPeriodServerError),
    UnknownValue(serde_json::Value),
}


/// Fetches detailed information about a single member within a space. The endpoint returns the member’s identifier, name, icon, identity, global name, status and role. The member_id path parameter can be provided as either the member's ID (starting  with `_participant`) or the member's identity. This is useful for user profile pages, permission management, and displaying member-specific information in collaborative environments.
pub async fn get_member(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, member_id: &str) -> Result<models::ApimodelPeriodMemberResponse, Error<GetMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_anytype_version = anytype_version;
    let p_space_id = space_id;
    let p_member_id = member_id;

    let uri_str = format!("{}/v1/spaces/{space_id}/members/{member_id}", configuration.base_path, space_id=crate::apis::urlencode(p_space_id), member_id=crate::apis::urlencode(p_member_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApimodelPeriodMemberResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApimodelPeriodMemberResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of members belonging to the specified space. Each member record includes the member’s profile ID, name, icon (which may be derived from an emoji or image), network identity, global name, status (e.g. joining, active) and role (e.g. Viewer, Editor, Owner). This endpoint supports collaborative features by allowing clients to show who is in a space and manage access rights.
pub async fn list_members(configuration: &configuration::Configuration, anytype_version: &str, space_id: &str, offset: Option<i32>, limit: Option<i32>) -> Result<models::PaginationPeriodPaginatedResponseApimodelMember, Error<ListMembersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_anytype_version = anytype_version;
    let p_space_id = space_id;
    let p_offset = offset;
    let p_limit = limit;

    let uri_str = format!("{}/v1/spaces/{space_id}/members", configuration.base_path, space_id=crate::apis::urlencode(p_space_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Anytype-Version", p_anytype_version.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginationPeriodPaginatedResponseApimodelMember`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginationPeriodPaginatedResponseApimodelMember`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListMembersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

